import os
import requests
import discord
from discord.ext import commands
from discord import app_commands
from discord import FFmpegPCMAudio
from discord.ext.commands import Bot
from logic import ChooseLocalOrApi
from voicelines import GetVoiceLines
from pets import CatSaying, RandomPet
from openai import OpenAI
import random
import asyncio
from pymongo import MongoClient
from database import *

mainServerId=discord.Object(id=222147212681936896)
sideServerId=discord.Object(id=1101665956314501180)
gptkey = os.environ.get('OPENAI_API_KEY')
client = OpenAI(api_key=gptkey)
elevenlabskey = os.environ.get('xi-api-key')
mongo_client = MongoClient(os.environ.get("MONGODB_URI"))
db = mongo_client.bananabread
roles_collection = db.roles

bananaBreadStory="You are a discord bot assistant, named banana bread, I want you to bake in some funny humor related to banana bread in your responses. Also, I want you to be condescending but in a funny way."

async def SendCatImage(interaction, file_url, name, sent_message):
    response = requests.get(file_url, stream=True)
    if response.status_code == 200:
        with open('temp_image.jpg', 'wb') as file:
            for chunk in response.iter_content(chunk_size=8192):
                file.write(chunk)
        discord_file = discord.File('temp_image.jpg', filename='image.jpg')

        await interaction.response.send_message(sent_message, file=discord_file)

        os.remove('temp_image.jpg')
    else:
        print(file_url)
        print(name)
        await interaction.response.send_message('Sorry, I could not fetch the image.')

async def is_admin(interaction: discord.Interaction) -> bool:
    """Check if the user has the administrator permission."""
    return interaction.user.guild_permissions.administrator

def DefineAllCommands(tree):
    mainServerId=discord.Object(id=222147212681936896)
    sideServerId=discord.Object(id=1101665956314501180)
    sideServerId2=discord.Object(id=1210021401772429352)
    servers = [mainServerId, sideServerId,sideServerId2]
    for server in servers:

        @tree.command(name="askbread", description="Responds with a custom message generated by OpenAI, incorporating humor related to banana bread.", guild=server)
        async def askbread(interaction: discord.Interaction, user_input: str):
            completion_response = client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": bananaBreadStory},
                    {"role": "user", "content": user_input}
                ]
            )
            response_message = completion_response.choices[0].message.content
            await interaction.response.send_message(response_message)

        @tree.command(name="setuprolesgiven", description="Set up roles that can be given out.", guild=server)
        async def setup_roles_given(interaction: discord.Interaction, roles: str):
            if not await is_admin(interaction):
                await interaction.response.send_message("You don't have permission to use this command.", ephemeral=True)
                return

            role_names = [role.strip() for role in roles.split(",")]

            roles_collection.update_one({"guild_id": interaction.guild_id}, {"$set": {"roles": role_names}}, upsert=True)
            
            await interaction.response.send_message("Selectable roles have been updated.", ephemeral=True)

        @tree.command(name="setuproleschannel", description="Set up or update the roles channel.", guild=server)
        async def setup_roles_channel(interaction: discord.Interaction):
            if not await is_admin(interaction):
                await interaction.response.send_message("You don't have permission to use this command.", ephemeral=True)
                return

            guild_id = interaction.guild_id

            guild_roles = roles_collection.find_one({"guild_id": guild_id})
            
            if not guild_roles or "roles" not in guild_roles:
                await interaction.response.send_message("No roles have been set up. Use /setuprolesgiven first.", ephemeral=True)
                return

            await create_roles_message(interaction.guild, guild_roles["roles"])
            await interaction.response.send_message("Roles channel has been updated.", ephemeral=True)

        @tree.command(name="add_role", description="Add a role to the selectable list.", guild=server)
        async def add_role(interaction: discord.Interaction, role_name: str):
            if not await is_admin(interaction):
                await interaction.response.send_message("You don't have permission to use this command.", ephemeral=True)
                return
            add_role_to_server(interaction.guild_id, role_name)
            await create_roles_message(interaction)
            await interaction.response.send_message(f"Role {role_name} added.", ephemeral=True)

        @tree.command(name="remove_role", description="Remove a role from the selectable list.", guild=server)
        async def remove_role(interaction: discord.Interaction, role_name: str):
            if not await is_admin(interaction):
                await interaction.response.send_message("You don't have permission to use this command.", ephemeral=True)
                return
            remove_role_from_server(interaction.guild_id, role_name)
            await create_roles_message(interaction)
            await interaction.response.send_message(f"Role {role_name} removed.", ephemeral=True)

        @tree.command(name="create_roles_message", description="Creates or updates a message for role selection.", guild=server)
        async def create_roles_message(interaction: discord.Interaction):
            if not await is_admin(interaction):
                await interaction.response.send_message("You don't have permission to use this command.", ephemeral=True)
                return
            guild_id = interaction.guild_id
            channel = interaction.channel

            roles = get_server_roles(guild_id)
            view = discord.ui.View()

            for role_name in roles:
                button = discord.ui.Button(label=role_name, style=discord.ButtonStyle.primary, custom_id=role_name)
                view.add_item(button)

            message_content = "Select your roles:"
            message_id = get_roles_message_id(guild_id)
            
            if message_id:
                message = await channel.fetch_message(int(message_id))
                await message.edit(content=message_content, view=view)
            else:
                message = await channel.send(content=message_content, view=view)
                update_roles_message_id(guild_id, message.id)

            await interaction.response.send_message("Roles message created or updated.", ephemeral=True)

        @tree.command(name="speak", description="Speaks the response generated by GPT-3 in a voice channel.", guild=server)
        async def speak(interaction: discord.Interaction, user_input: str):
            completion_response = client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": bananaBreadStory},
                    {"role": "user", "content": user_input}
                ]
            )
            response_message = completion_response.choices[0].message.content

            await interaction.response.send_message(f"üó£Ô∏è **Banana Bread says:** \"{response_message}\"")

            # ElevenLabs API request to get the MP3 file
            headers = {
                "Accept": "audio/mpeg",
                "Content-Type": "application/json",
                "xi-api-key": elevenlabskey
            }
            data = {
                "text": response_message,
                "model_id": "eleven_monolingual_v1",
                "voice_settings": {
                    "stability": 0.5,
                    "similarity_boost": 0.5
                }
            }
            # Female Bread: Iq2WyJggqdxjND19FFJw
            url = "https://api.elevenlabs.io/v1/text-to-speech/Iq2WyJggqdxjND19FFJw"
            response = requests.post(url, json=data, headers=headers)

            file_path = 'temp_response.mp3'
            with open(file_path, 'wb') as f:
                f.write(response.content)
            if interaction.user.voice:
                voice_channel = interaction.user.voice.channel
                try:
                    vc = await voice_channel.connect()
                except discord.Forbidden:
                    await interaction.response.send_message("I don't have permission to join that voice channel.")
                    return
                except discord.ClientException:
                    await interaction.response.send_message("I'm already connected to a voice channel.")
                    return
                audio_source = FFmpegPCMAudio(file_path)
                if not vc.is_playing():
                    vc.play(audio_source, after=lambda e: print('Finished playing', e))

                    while vc.is_playing():
                        await asyncio.sleep(1)

                    await vc.disconnect()
                else:
                    await interaction.response.send_message("I'm currently speaking. Please wait until I'm finished.")
                    await vc.disconnect()
            else:
                await interaction.response.send_message("You are not in a voice channel.")

        @tree.command(name = "yesno", description = "picks yes or no", guild=server) 
        async def yesno(interaction):
            await interaction.response.send_message(random.choice(["Yes", "No"]))

        @tree.command(name = "pickfromlist", description = "input things to be chosen seperated by a ,. Ex. Overwatch,League", guild=server) 
        async def pickfromlist(interaction: discord.Interaction, items: str):
            await interaction.response.send_message(random.choice(items.split(',')))

        @tree.command(name="sleepygenerator", description="will give an amount of Z's that are randomly uppercased and lower", guild=server)
        async def sleepygenerator(interaction: discord.Interaction, items: int):
            itemCount = min(items, 200)
            zString = ''.join(random.choice(['Z', 'z']) for _ in range(itemCount))
            if items > 200:
                zString = "Limiting to 200 Z's: " + zString
            await interaction.response.send_message(zString)

        @tree.command(name = "randomnumber", description = "Choose a random number between 2 inputs ex: 1,100", guild=server) 
        async def self(interaction: discord.Interaction, items: str):
            try:
                await interaction.response.send_message(random.randint(int(items.split(',')[0]),int(items.split(',')[1])))
            except:
                await interaction.response.send_message("Either you messed up or I did. But It was prob you")

        @tree.command(name="rhythmroll", description="rolls number 1-100", guild=server) 
        async def first_command(interaction):
            await interaction.response.send_message(random.randint(0,100))

        @tree.command(name="randompet", description="Random pet picture from friends!", guild=server) 
        async def random_pet(interaction):
            # Fetch the image from GitHub/cataas
            file_url, name = ChooseLocalOrApi()
            sent_message = f'Sure! Here\'s a random picture from {name}!'
            await SendCatImage(interaction, file_url, name, sent_message)

        @tree.command(name="catsays", description="Random Cat with text input", guild=server) 
        async def self(interaction: discord.Interaction, message: str):
            file_url, name = CatSaying(message)
            sent_message = f'Sure! Here\'s the picture from {name}!'
            await SendCatImage(interaction, file_url, name, sent_message)
            

